#!/bin/bash

# Renderers defined here must be applied to any/all templates.

render_mod_params ()
{
    local template=$1
    local config_renderer=
    export INTERNAL_BUNDLE_CONFIG=

    declare -A CHANNEL_DEFAULT=( [cs:]=stable [ch:]=latest/stable )
    local store=${MASTER_OPTS[CHARM_STORE]}
    local store_default_channel=${CHANNEL_DEFAULT[$store]}
    local service_default_channel=${MASTER_OPTS[DEFAULT_CHANNEL]:-$store_default_channel}
    local channel

    local charms
    # get list of charms in this template
    readarray -t charms<<<`sed -rn 's,.+ charm:\s+.+__CHARM_CH_PREFIX__(__SKIP_PREFIX__)?(.+)\s*$,\2,p' $template`

    config_renderer=`mktemp`
    export INTERNAL_BUNDLE_CONFIG=`mktemp`
    echo -n "sed -i " > $config_renderer

    for c in ${charms[@]}; do
        if [[ $store == "ch:" ]]; then
            # apply channel and prefix, if required, for each charm
            channel=${CHARM_CHANNEL[$c]:-$service_default_channel}
            echo "-e '/__CHARM_CS_NS____CHARM_CH_PREFIX__${c}\s*$/a\ \ \ \ channel: $channel'" >> $config_renderer

            if `grep -q "__SKIP_PREFIX__$c" $template`; then
                echo "-e 's,__CHARM_CS_NS____CHARM_CH_PREFIX____SKIP_PREFIX__${c}\s*$,${c},'" >> $config_renderer
            else
                prefix=${CH_PREFIXED_CHARMS[$c]:-""}
                echo "-e 's,__CHARM_CS_NS____CHARM_CH_PREFIX__${c}\s*$,$prefix${c},'" >> $config_renderer
            fi
        else
            # apply ns, if required, for each charm
            ns=${CS_NS_CHARMS[$c]:-""}
            echo "-e 's,__CHARM_CS_NS____CHARM_CH_PREFIX__${c}\s*$,$ns${c},'" >> $config_renderer
        fi
    done

    echo "-e 's,__CHARM_STORE__,$store,'" >> $config_renderer

    if ((${#MOD_PARAMS[@]})); then
        for p in ${!MOD_PARAMS[@]}; do
            echo -n "-e 's,$p,${MOD_PARAMS[$p]},g' " >> $config_renderer
            echo "${p}: \"${MOD_PARAMS[$p]}\"" >> $INTERNAL_BUNDLE_CONFIG
        done
    fi

    # apply it
    eval `cat $config_renderer` "$template"
    rm -rf $config_renderer
}

__generate_app_mysql_inndodb_router ()
{
    local app="$1"
    local app_part=$RENDER_PARTS_DIR/mysql/applications/${app}-mysql-innodb-cluster-router.part

    mkdir -p $RENDER_PARTS_DIR/mysql/{applications,relations}
cat << EOF > $app_part
  $app-mysql-router:
    charm: __CHARM_STORE____CHARM_CS_NS____CHARM_CH_PREFIX__mysql-router
EOF
    render_mod_params $app_part

cat << EOF > $RENDER_PARTS_DIR/mysql/relations/$app-mysql-innodb-cluster-router.part
  - [ mysql:db-router, $app-mysql-router:db-router ]
EOF
}

__create_mysql_interface_parts ()
{
    local template=$1
    local templates_path=$2
    local template_short=`basename $1`
    local template_key=__APPLICATION_MYSQL_INNODB_ROUTER__

    readarray -t lines<<<"`grep "$template_key" $template`"
    ((${#lines[@]})) && [ -n "${lines[0]}" ] || return 0
    for line in "${lines[@]}"; do
        app=`echo $line| sed -r "s/.*\s+([[:alnum:]\-]+):shared-db.*/\1/g"`
        [ -n "$app" ] || continue
        sed -i -r "s/($app:shared-db\s*,\s*)$template_key/\1$app-mysql-router:shared-db/g" $template
        __generate_app_mysql_inndodb_router $app
    done
}

__create_yaml_dict_entry ()
{
    local section=$1
    shift

    cat <<- EOF
	$section:
	$@
	EOF
}

aggregate_mysql_interface_parts()
{
    # this is called once after all the individial mysql application interface
    # parts have been created.
    local rendered_path=$1
    local dir

    [ -d "$RENDER_PARTS_DIR/mysql" ] || return 0

    ((`find $RENDER_PARTS_DIR/mysql -type f| wc -l`)) || return 0

    # this function is only expected to be called once so ensure clean file.
    echo -e "# overlay auto-generated by stsstack-bundles\n" > $rendered_path/mysql-innodb-cluster-router.yaml
    for key in applications relations; do
        dir=$RENDER_PARTS_DIR/mysql/$key
        [ -d "$dir" ] || return 0
        __create_yaml_dict_entry $key "`cat $dir/*`" >> $rendered_path/mysql-innodb-cluster-router.yaml
    done
}

# Each custom bundle generator can specify a set of parameters to apply to
# bundle templates as variables. They are converted into a sed statement that
# is passed in to here inside a file and run against the template(s). There is
# therefore no need to add parameters to this function and they should only
# be defined in the custom generators.
render () {
    local charm_current
    local charm_new
    local num_vips

    # generic parameters only
    sed -i "s,__SERIES__,$series,g" $1

    # service-specific replacements
    render_mod_params $1

    num_vips=$(grep -c __VIP__ $1) || true
    if ((num_vips)); then
        for ((i=0;i<num_vips;i++)); do
            vip=$VIP_START_PREFIX.$((VIP_START_SUFFIX++))
            sed -i "0,/__VIP__/s//$vip/" $1
        done
    fi

    # Process charm revisions from bundle first.
    for key in ${!MASTER_OPTS[@]}; do
        prefix="CHARM_REVISIONS\."
        # skip any key that isnt a charm revision
        [[ ${key##$prefix} != $key ]] || continue
        charm_current=${key##$prefix}
        charm_new=${MASTER_OPTS[$key]}
        # skip if the charm we are replacing isnt in the template
        grep -q $charm_current $1 || continue
        sed -i -r "s,charm:.*${charm_current}\$,charm: $charm_new," $1
    done

    # render mysql interface if exists
    # note: no changes applied until aggregate_mysql_interface_parts()
    #       called so be sure to do so once all rendering complete.
    __create_mysql_interface_parts $1 $MOD_DIR/overlays
}

